{"ast":null,"code":"/**\n * \n * Firestore Transaction representation wrapper\n */\nimport { getAppEventName, SharedEventEmitter } from '../../utils/events';\nimport { getNativeModule } from '../../utils/native';\nimport Transaction from './Transaction';\nlet transactionId = 0;\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\n\nconst generateTransactionId = () => transactionId++;\n\n/**\n * @class TransactionHandler\n */\nexport default class TransactionHandler {\n  constructor(firestore) {\n    this._pending = {};\n    this._firestore = firestore;\n    SharedEventEmitter.addListener(getAppEventName(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n  /**\n   * -------------\n   * INTERNAL API\n   * -------------\n   */\n\n  /**\n   * Add a new transaction and start it natively.\n   * @param updateFunction\n   */\n\n  _add(updateFunction) {\n    const id = generateTransactionId(); // $FlowExpectedError: Transaction has to be populated\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new Transaction(this._firestore, meta)\n    }; // deferred promise\n\n    return new Promise((resolve, reject) => {\n      getNativeModule(this._firestore).transactionBegin(id);\n      meta.resolve = r => {\n        resolve(r);\n        this._remove(id);\n      };\n      meta.reject = e => {\n        reject(e);\n        this._remove(id);\n      };\n    });\n  }\n  /**\n   * Destroys a local instance of a transaction meta\n   *\n   * @param id\n   * @private\n   */\n\n  _remove(id) {\n    getNativeModule(this._firestore).transactionDispose(id);\n    delete this._pending[id];\n  }\n  /**\n   * -------------\n   *    EVENTS\n   * -------------\n   */\n\n  /**\n   * Handles incoming native transaction events and distributes to correct\n   * internal handler by event.type\n   *\n   * @param event\n   * @returns {*}\n   * @private\n   */\n\n  _handleTransactionEvent(event) {\n    // eslint-disable-next-line default-case\n    switch (event.type) {\n      case 'update':\n        this._handleUpdate(event);\n        break;\n      case 'error':\n        this._handleError(event);\n        break;\n      case 'complete':\n        this._handleComplete(event);\n        break;\n    }\n  }\n  /**\n   * Handles incoming native transaction update events\n   *\n   * @param event\n   * @private\n   */\n\n  async _handleUpdate(event) {\n    const {\n      id\n    } = event; // abort if no longer exists js side\n\n    if (!this._pending[id]) return this._remove(id);\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta; // clear any saved state from previous transaction runs\n\n    transaction._prepare();\n    let finalError;\n    let updateFailed;\n    let pendingResult; // run the users custom update functionality\n\n    try {\n      const possiblePromise = updateFunction(transaction); // validate user has returned a promise in their update function\n      // TODO must it actually return a promise? Can't find any usages of it without one...\n\n      if (!possiblePromise || !possiblePromise.then) {\n        finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n      } else {\n        pendingResult = await possiblePromise;\n      }\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    } // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n\n    if (updateFailed || finalError) {\n      // $FlowExpectedError: Reject will always be present\n      return reject(finalError);\n    } // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n\n    transaction._pendingResult = pendingResult; // send the buffered update/set/delete commands for native to process\n\n    return getNativeModule(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n  /**\n   * Handles incoming native transaction error events\n   *\n   * @param event\n   * @private\n   */\n\n  _handleError(event) {\n    const {\n      id,\n      error\n    } = event;\n    const {\n      meta\n    } = this._pending[id];\n    if (meta && error) {\n      const {\n        code,\n        message\n      } = error; // build a JS error and replace its stack\n      // with the captured one at start of transaction\n      // so it's actually relevant to the user\n\n      const errorWithStack = new Error(message); // $FlowExpectedError: code is needed for Firebase errors\n\n      errorWithStack.code = code; // $FlowExpectedError: stack should be a stack trace\n\n      errorWithStack.stack = `Error: ${message}\\n${meta.stack}`; // $FlowExpectedError: Reject will always be present\n\n      meta.reject(errorWithStack);\n    }\n  }\n  /**\n   * Handles incoming native transaction complete events\n   *\n   * @param event\n   * @private\n   */\n\n  _handleComplete(event) {\n    const {\n      id\n    } = event;\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    if (meta) {\n      const pendingResult = transaction._pendingResult; // $FlowExpectedError: Resolve will always be present\n\n      meta.resolve(pendingResult);\n    }\n  }\n}","map":{"version":3,"names":["getAppEventName","SharedEventEmitter","getNativeModule","Transaction","transactionId","generateTransactionId","TransactionHandler","constructor","firestore","_pending","_firestore","addListener","_handleTransactionEvent","bind","_add","updateFunction","id","meta","stack","Error","split","slice","join","transaction","Promise","resolve","reject","transactionBegin","r","_remove","e","transactionDispose","event","type","_handleUpdate","_handleError","_handleComplete","_prepare","finalError","updateFailed","pendingResult","possiblePromise","then","exception","_pendingResult","transactionApplyBuffer","_commandBuffer","error","code","message","errorWithStack"],"sources":["/Users/sharusan/MeetMyCar/myapp/node_modules/react-native-firebase/dist/modules/firestore/TransactionHandler.js"],"sourcesContent":["/**\n * \n * Firestore Transaction representation wrapper\n */\nimport { getAppEventName, SharedEventEmitter } from '../../utils/events';\nimport { getNativeModule } from '../../utils/native';\nimport Transaction from './Transaction';\nlet transactionId = 0;\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\n\nconst generateTransactionId = () => transactionId++;\n\n/**\n * @class TransactionHandler\n */\nexport default class TransactionHandler {\n  constructor(firestore) {\n    this._pending = {};\n    this._firestore = firestore;\n    SharedEventEmitter.addListener(getAppEventName(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n  /**\n   * -------------\n   * INTERNAL API\n   * -------------\n   */\n\n  /**\n   * Add a new transaction and start it natively.\n   * @param updateFunction\n   */\n\n\n  _add(updateFunction) {\n    const id = generateTransactionId(); // $FlowExpectedError: Transaction has to be populated\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new Transaction(this._firestore, meta)\n    }; // deferred promise\n\n    return new Promise((resolve, reject) => {\n      getNativeModule(this._firestore).transactionBegin(id);\n\n      meta.resolve = r => {\n        resolve(r);\n\n        this._remove(id);\n      };\n\n      meta.reject = e => {\n        reject(e);\n\n        this._remove(id);\n      };\n    });\n  }\n  /**\n   * Destroys a local instance of a transaction meta\n   *\n   * @param id\n   * @private\n   */\n\n\n  _remove(id) {\n    getNativeModule(this._firestore).transactionDispose(id);\n    delete this._pending[id];\n  }\n  /**\n   * -------------\n   *    EVENTS\n   * -------------\n   */\n\n  /**\n   * Handles incoming native transaction events and distributes to correct\n   * internal handler by event.type\n   *\n   * @param event\n   * @returns {*}\n   * @private\n   */\n\n\n  _handleTransactionEvent(event) {\n    // eslint-disable-next-line default-case\n    switch (event.type) {\n      case 'update':\n        this._handleUpdate(event);\n\n        break;\n\n      case 'error':\n        this._handleError(event);\n\n        break;\n\n      case 'complete':\n        this._handleComplete(event);\n\n        break;\n    }\n  }\n  /**\n   * Handles incoming native transaction update events\n   *\n   * @param event\n   * @private\n   */\n\n\n  async _handleUpdate(event) {\n    const {\n      id\n    } = event; // abort if no longer exists js side\n\n    if (!this._pending[id]) return this._remove(id);\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta; // clear any saved state from previous transaction runs\n\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult; // run the users custom update functionality\n\n    try {\n      const possiblePromise = updateFunction(transaction); // validate user has returned a promise in their update function\n      // TODO must it actually return a promise? Can't find any usages of it without one...\n\n      if (!possiblePromise || !possiblePromise.then) {\n        finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n      } else {\n        pendingResult = await possiblePromise;\n      }\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    } // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n\n\n    if (updateFailed || finalError) {\n      // $FlowExpectedError: Reject will always be present\n      return reject(finalError);\n    } // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n\n\n    transaction._pendingResult = pendingResult; // send the buffered update/set/delete commands for native to process\n\n    return getNativeModule(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n  /**\n   * Handles incoming native transaction error events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleError(event) {\n    const {\n      id,\n      error\n    } = event;\n    const {\n      meta\n    } = this._pending[id];\n\n    if (meta && error) {\n      const {\n        code,\n        message\n      } = error; // build a JS error and replace its stack\n      // with the captured one at start of transaction\n      // so it's actually relevant to the user\n\n      const errorWithStack = new Error(message); // $FlowExpectedError: code is needed for Firebase errors\n\n      errorWithStack.code = code; // $FlowExpectedError: stack should be a stack trace\n\n      errorWithStack.stack = `Error: ${message}\\n${meta.stack}`; // $FlowExpectedError: Reject will always be present\n\n      meta.reject(errorWithStack);\n    }\n  }\n  /**\n   * Handles incoming native transaction complete events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleComplete(event) {\n    const {\n      id\n    } = event;\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n\n    if (meta) {\n      const pendingResult = transaction._pendingResult; // $FlowExpectedError: Resolve will always be present\n\n      meta.resolve(pendingResult);\n    }\n  }\n\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,eAAe,EAAEC,kBAAkB,QAAQ,oBAAoB;AACxE,SAASC,eAAe,QAAQ,oBAAoB;AACpD,OAAOC,WAAW,MAAM,eAAe;AACvC,IAAIC,aAAa,GAAG,CAAC;AACrB;AACA;AACA;AACA;AACA;;AAEA,MAAMC,qBAAqB,GAAGA,CAAA,KAAMD,aAAa,EAAE;;AAEnD;AACA;AACA;AACA,eAAe,MAAME,kBAAkB,CAAC;EACtCC,WAAWA,CAACC,SAAS,EAAE;IACrB,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC;IAClB,IAAI,CAACC,UAAU,GAAGF,SAAS;IAC3BP,kBAAkB,CAACU,WAAW,CAACX,eAAe,CAAC,IAAI,CAACU,UAAU,EAAE,6BAA6B,CAAC,EAAE,IAAI,CAACE,uBAAuB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAC1I;EACA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;;EAGEC,IAAIA,CAACC,cAAc,EAAE;IACnB,MAAMC,EAAE,GAAGX,qBAAqB,CAAC,CAAC,CAAC,CAAC;;IAEpC,MAAMY,IAAI,GAAG;MACXD,EAAE;MACFD,cAAc;MACdG,KAAK,EAAE,IAAIC,KAAK,CAAC,CAAC,CAACD,KAAK,CAACE,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI;IACzD,CAAC;IACD,IAAI,CAACb,QAAQ,CAACO,EAAE,CAAC,GAAG;MAClBC,IAAI;MACJM,WAAW,EAAE,IAAIpB,WAAW,CAAC,IAAI,CAACO,UAAU,EAAEO,IAAI;IACpD,CAAC,CAAC,CAAC;;IAEH,OAAO,IAAIO,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCxB,eAAe,CAAC,IAAI,CAACQ,UAAU,CAAC,CAACiB,gBAAgB,CAACX,EAAE,CAAC;MAErDC,IAAI,CAACQ,OAAO,GAAGG,CAAC,IAAI;QAClBH,OAAO,CAACG,CAAC,CAAC;QAEV,IAAI,CAACC,OAAO,CAACb,EAAE,CAAC;MAClB,CAAC;MAEDC,IAAI,CAACS,MAAM,GAAGI,CAAC,IAAI;QACjBJ,MAAM,CAACI,CAAC,CAAC;QAET,IAAI,CAACD,OAAO,CAACb,EAAE,CAAC;MAClB,CAAC;IACH,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;;EAGEa,OAAOA,CAACb,EAAE,EAAE;IACVd,eAAe,CAAC,IAAI,CAACQ,UAAU,CAAC,CAACqB,kBAAkB,CAACf,EAAE,CAAC;IACvD,OAAO,IAAI,CAACP,QAAQ,CAACO,EAAE,CAAC;EAC1B;EACA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAGEJ,uBAAuBA,CAACoB,KAAK,EAAE;IAC7B;IACA,QAAQA,KAAK,CAACC,IAAI;MAChB,KAAK,QAAQ;QACX,IAAI,CAACC,aAAa,CAACF,KAAK,CAAC;QAEzB;MAEF,KAAK,OAAO;QACV,IAAI,CAACG,YAAY,CAACH,KAAK,CAAC;QAExB;MAEF,KAAK,UAAU;QACb,IAAI,CAACI,eAAe,CAACJ,KAAK,CAAC;QAE3B;IACJ;EACF;EACA;AACF;AACA;AACA;AACA;AACA;;EAGE,MAAME,aAAaA,CAACF,KAAK,EAAE;IACzB,MAAM;MACJhB;IACF,CAAC,GAAGgB,KAAK,CAAC,CAAC;;IAEX,IAAI,CAAC,IAAI,CAACvB,QAAQ,CAACO,EAAE,CAAC,EAAE,OAAO,IAAI,CAACa,OAAO,CAACb,EAAE,CAAC;IAC/C,MAAM;MACJC,IAAI;MACJM;IACF,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACO,EAAE,CAAC;IACrB,MAAM;MACJD,cAAc;MACdW;IACF,CAAC,GAAGT,IAAI,CAAC,CAAC;;IAEVM,WAAW,CAACc,QAAQ,CAAC,CAAC;IAEtB,IAAIC,UAAU;IACd,IAAIC,YAAY;IAChB,IAAIC,aAAa,CAAC,CAAC;;IAEnB,IAAI;MACF,MAAMC,eAAe,GAAG1B,cAAc,CAACQ,WAAW,CAAC,CAAC,CAAC;MACrD;;MAEA,IAAI,CAACkB,eAAe,IAAI,CAACA,eAAe,CAACC,IAAI,EAAE;QAC7CJ,UAAU,GAAG,IAAInB,KAAK,CAAC,uFAAuF,CAAC;MACjH,CAAC,MAAM;QACLqB,aAAa,GAAG,MAAMC,eAAe;MACvC;IACF,CAAC,CAAC,OAAOE,SAAS,EAAE;MAClB;MACA;MACAJ,YAAY,GAAG,IAAI;MACnBD,UAAU,GAAGK,SAAS;IACxB,CAAC,CAAC;IACF;IACA;;IAGA,IAAIJ,YAAY,IAAID,UAAU,EAAE;MAC9B;MACA,OAAOZ,MAAM,CAACY,UAAU,CAAC;IAC3B,CAAC,CAAC;IACF;IACA;;IAGAf,WAAW,CAACqB,cAAc,GAAGJ,aAAa,CAAC,CAAC;;IAE5C,OAAOtC,eAAe,CAAC,IAAI,CAACQ,UAAU,CAAC,CAACmC,sBAAsB,CAAC7B,EAAE,EAAEO,WAAW,CAACuB,cAAc,CAAC;EAChG;EACA;AACF;AACA;AACA;AACA;AACA;;EAGEX,YAAYA,CAACH,KAAK,EAAE;IAClB,MAAM;MACJhB,EAAE;MACF+B;IACF,CAAC,GAAGf,KAAK;IACT,MAAM;MACJf;IACF,CAAC,GAAG,IAAI,CAACR,QAAQ,CAACO,EAAE,CAAC;IAErB,IAAIC,IAAI,IAAI8B,KAAK,EAAE;MACjB,MAAM;QACJC,IAAI;QACJC;MACF,CAAC,GAAGF,KAAK,CAAC,CAAC;MACX;MACA;;MAEA,MAAMG,cAAc,GAAG,IAAI/B,KAAK,CAAC8B,OAAO,CAAC,CAAC,CAAC;;MAE3CC,cAAc,CAACF,IAAI,GAAGA,IAAI,CAAC,CAAC;;MAE5BE,cAAc,CAAChC,KAAK,GAAI,UAAS+B,OAAQ,KAAIhC,IAAI,CAACC,KAAM,EAAC,CAAC,CAAC;;MAE3DD,IAAI,CAACS,MAAM,CAACwB,cAAc,CAAC;IAC7B;EACF;EACA;AACF;AACA;AACA;AACA;AACA;;EAGEd,eAAeA,CAACJ,KAAK,EAAE;IACrB,MAAM;MACJhB;IACF,CAAC,GAAGgB,KAAK;IACT,MAAM;MACJf,IAAI;MACJM;IACF,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACO,EAAE,CAAC;IAErB,IAAIC,IAAI,EAAE;MACR,MAAMuB,aAAa,GAAGjB,WAAW,CAACqB,cAAc,CAAC,CAAC;;MAElD3B,IAAI,CAACQ,OAAO,CAACe,aAAa,CAAC;IAC7B;EACF;AAEF"},"metadata":{},"sourceType":"module","externalDependencies":[]}