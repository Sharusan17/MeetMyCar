{"ast":null,"code":"import FieldPath from '../FieldPath';\nimport { isObject, isString } from '../../../utils';\nconst buildFieldPathData = (segments, value) => {\n  if (segments.length === 1) {\n    return {\n      [segments[0]]: value\n    };\n  }\n  return {\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n}; // eslint-disable-next-line import/prefer-default-export\n\nexport const mergeFieldPathData = (data, segments, value) => {\n  if (segments.length === 1) {\n    return {\n      ...data,\n      [segments[0]]: value\n    };\n  }\n  if (data[segments[0]]) {\n    return {\n      ...data,\n      [segments[0]]: mergeFieldPathData(data[segments[0]], segments.slice(1), value)\n    };\n  }\n  return {\n    ...data,\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n};\nexport const parseUpdateArgs = (args, methodName) => {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n};","map":{"version":3,"names":["FieldPath","isObject","isString","buildFieldPathData","segments","value","length","slice","mergeFieldPathData","data","parseUpdateArgs","args","methodName","Error","i","key","_segments"],"sources":["/Users/sharusan/MeetMyCar/myapp/node_modules/react-native-firebase/dist/modules/firestore/utils/index.js"],"sourcesContent":["import FieldPath from '../FieldPath';\nimport { isObject, isString } from '../../../utils';\n\nconst buildFieldPathData = (segments, value) => {\n  if (segments.length === 1) {\n    return {\n      [segments[0]]: value\n    };\n  }\n\n  return {\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n}; // eslint-disable-next-line import/prefer-default-export\n\n\nexport const mergeFieldPathData = (data, segments, value) => {\n  if (segments.length === 1) {\n    return { ...data,\n      [segments[0]]: value\n    };\n  }\n\n  if (data[segments[0]]) {\n    return { ...data,\n      [segments[0]]: mergeFieldPathData(data[segments[0]], segments.slice(1), value)\n    };\n  }\n\n  return { ...data,\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n};\nexport const parseUpdateArgs = (args, methodName) => {\n  let data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n\n  return data;\n};"],"mappings":"AAAA,OAAOA,SAAS,MAAM,cAAc;AACpC,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,gBAAgB;AAEnD,MAAMC,kBAAkB,GAAGA,CAACC,QAAQ,EAAEC,KAAK,KAAK;EAC9C,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACzB,OAAO;MACL,CAACF,QAAQ,CAAC,CAAC,CAAC,GAAGC;IACjB,CAAC;EACH;EAEA,OAAO;IACL,CAACD,QAAQ,CAAC,CAAC,CAAC,GAAGD,kBAAkB,CAACC,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,EAAEF,KAAK;EAC5D,CAAC;AACH,CAAC,CAAC,CAAC;;AAGH,OAAO,MAAMG,kBAAkB,GAAGA,CAACC,IAAI,EAAEL,QAAQ,EAAEC,KAAK,KAAK;EAC3D,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACzB,OAAO;MAAE,GAAGG,IAAI;MACd,CAACL,QAAQ,CAAC,CAAC,CAAC,GAAGC;IACjB,CAAC;EACH;EAEA,IAAII,IAAI,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;IACrB,OAAO;MAAE,GAAGK,IAAI;MACd,CAACL,QAAQ,CAAC,CAAC,CAAC,GAAGI,kBAAkB,CAACC,IAAI,CAACL,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,EAAEF,KAAK;IAC/E,CAAC;EACH;EAEA,OAAO;IAAE,GAAGI,IAAI;IACd,CAACL,QAAQ,CAAC,CAAC,CAAC,GAAGD,kBAAkB,CAACC,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC,EAAEF,KAAK;EAC5D,CAAC;AACH,CAAC;AACD,OAAO,MAAMK,eAAe,GAAGA,CAACC,IAAI,EAAEC,UAAU,KAAK;EACnD,IAAIH,IAAI,GAAG,CAAC,CAAC;EAEb,IAAIE,IAAI,CAACL,MAAM,KAAK,CAAC,EAAE;IACrB,IAAI,CAACL,QAAQ,CAACU,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;MACtB,MAAM,IAAIE,KAAK,CAAE,GAAED,UAAW,mEAAkE,CAAC;IACnG;IAEA,CAACH,IAAI,CAAC,GAAGE,IAAI;EACf,CAAC,MAAM,IAAIA,IAAI,CAACL,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IAChC,MAAM,IAAIO,KAAK,CAAE,GAAED,UAAW,6GAA4G,CAAC;EAC7I,CAAC,MAAM;IACL,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACL,MAAM,EAAEQ,CAAC,IAAI,CAAC,EAAE;MACvC,MAAMC,GAAG,GAAGJ,IAAI,CAACG,CAAC,CAAC;MACnB,MAAMT,KAAK,GAAGM,IAAI,CAACG,CAAC,GAAG,CAAC,CAAC;MAEzB,IAAIZ,QAAQ,CAACa,GAAG,CAAC,EAAE;QACjBN,IAAI,CAACM,GAAG,CAAC,GAAGV,KAAK;MACnB,CAAC,MAAM,IAAIU,GAAG,YAAYf,SAAS,EAAE;QACnCS,IAAI,GAAGD,kBAAkB,CAACC,IAAI,EAAEM,GAAG,CAACC,SAAS,EAAEX,KAAK,CAAC;MACvD,CAAC,MAAM;QACL,MAAM,IAAIQ,KAAK,CAAE,GAAED,UAAW,8BAA6BE,CAAE,gCAA+B,CAAC;MAC/F;IACF;EACF;EAEA,OAAOL,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}